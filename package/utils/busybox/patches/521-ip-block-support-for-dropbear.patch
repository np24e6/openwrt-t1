Index: busybox-1.34.1/Makefile
===================================================================
--- busybox-1.34.1.orig/Makefile
+++ busybox-1.34.1/Makefile
@@ -600,7 +600,7 @@ libs-y		:= $(libs-y1) $(libs-y2)
 # System.map is generated to document addresses of all kernel symbols

 busybox-all  := $(core-y) $(libs-y)
-
+CONFIG_EXTRA_LDLIBS:=ubus ubox uci log
 # Rule to link busybox - also used during CONFIG_KALLSYMS
 # May be overridden by arch/$(ARCH)/Makefile
 quiet_cmd_busybox__ ?= LINK    $@
Index: busybox-1.34.1/loginutils/login.c
===================================================================
--- busybox-1.34.1.orig/loginutils/login.c
+++ busybox-1.34.1/loginutils/login.c
@@ -69,6 +69,17 @@
 #include "libbb.h"
 #include "common_bufsiz.h"
 #include <syslog.h>
+#include <liblog.h>
+#include <libubus.h>
+#include <libubox/blobmsg.h>
+#include <string.h>
+#include <uci.h>
+
+static char ip_address[46];
+
+void unblock_ip(char* host, char *port);
+void block_ip(char *ip, char *port);
+static void push_log(char *format, ...);

 #if ENABLE_SELINUX
 # include <selinux/selinux.h>  /* for is_selinux_enabled()  */
@@ -330,6 +341,7 @@
 	int count = 0;
 	struct passwd *pw;
 	char *opt_host = NULL;
+	char *opt_port = NULL;
 	char *opt_user = opt_user; /* for compiler */
 	char *full_tty;
 	char *short_tty;
@@ -363,7 +375,7 @@
 	bb_daemon_helper(DAEMON_CLOSE_EXTRA_FDS);

 	username[0] = '\0';
-	opt = getopt32(argv, "f:h:p", &opt_user, &opt_host);
+	opt = getopt32(argv, "f:h:pP:", &opt_user, &opt_host, &opt_port);
 	if (opt & LOGIN_OPT_f) {
 		if (!run_by_root)
 			bb_simple_error_msg_and_die("-f is for root only");
@@ -392,9 +404,9 @@
 	short_tty = skip_dev_pfx(full_tty);

 	if (opt_host) {
-		fromhost = xasprintf(" on '%s' from '%s'", short_tty, opt_host);
+		fromhost = xasprintf(" on `%s` from `%s`", short_tty, opt_host);
 	} else {
-		fromhost = xasprintf(" on '%s'", short_tty);
+		fromhost = xasprintf(" on `%s`", short_tty);
 	}

 	/* Was breaking "login <username>" from shell command line: */
@@ -485,11 +497,9 @@
 		syslog(LOG_WARNING, "pam_%s call failed: %s (%d)", failed_msg,
 					pam_strerror(pamh, pamret), pamret);
 		login_pam_end(pamh);
-		safe_strncpy(username, "UNKNOWN", sizeof(username));
 #else /* not PAM */
 		pw = getpwnam(username);
 		if (!pw) {
-			strcpy(username, "UNKNOWN");
 			goto fake_it;
 		}

@@ -518,8 +528,12 @@
 		pause_after_failed_login();
 		/* TODO: doesn't sound like correct English phrase to me */
 		puts("Login incorrect");
-		syslog(LOG_WARNING, "invalid password for '%s'%s",
-					username, fromhost);
+		push_log("Invalid password for `%s` %s", username, fromhost);
+
+		if (opt_host) {
+			block_ip(opt_host, opt_port);
+		}
+
 		if (++count == 3) {
 			if (ENABLE_FEATURE_CLEAN_UP)
 				free(fromhost);
@@ -577,11 +591,16 @@
 	}
 #endif

+	/* Tell ip_blockd to unblock host, if provided. */
+	if (opt_host) {
+		unblock_ip(opt_host, opt_port);
+	}
+
 	if (access(".hushlogin", F_OK) != 0)
 		motd();

 	if (pw->pw_uid == 0)
-		syslog(LOG_INFO, "root login%s", fromhost);
+		push_log("Root login%s", fromhost);

 	if (ENABLE_FEATURE_CLEAN_UP)
 		free(fromhost);
@@ -616,3 +635,122 @@

 	/* return EXIT_FAILURE; - not reached */
 }
+
+void fix_mapped_ip(char *host){
+	char *host_copy = strdup(host);
+	char *token	= strtok(host_copy, ":");
+	while (token != NULL) {
+		strncpy(ip_address,token,sizeof(ip_address));
+		token = strtok(NULL, ":");
+	}
+	free(host_copy);
+}
+
+/* Calls ip_block unblock to clear the IP that just connected */
+void unblock_ip(char* host, char *port)
+{
+	struct ubus_context *ubus;
+	struct blob_buf b = { 0 };
+	uint32_t id	  = 0;
+	int ret		  = 0;
+
+	ubus = ubus_connect(NULL);
+
+	if (!ubus) {
+		syslog(LOG_ERR, "Failed to connect to ubus");
+		goto end;
+	}
+
+	if (!port){
+		goto end;
+	}
+
+	if (strstr(host,".")){ //if host is IPv4 mapped IPv6 address
+		fix_mapped_ip(host);
+	} else {
+		strncpy(ip_address,host,sizeof(ip_address));
+	}
+
+	ret = ubus_lookup_id(ubus, "ip_block", &id);
+	if (ret) {
+		syslog(LOG_ERR, "Failed to find 'ip_block' object");
+		goto end;
+	}
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ip", ip_address);
+	blobmsg_add_string(&b, "port", port);
+	ubus_invoke(ubus, id, "unblock", b.head, NULL, NULL, 1000);
+
+end:
+	blob_buf_free(&b);
+	ubus_free(ubus);
+}
+
+void block_ip(char* host, char *port)
+{
+	struct ubus_context *ubus;
+	struct blob_buf b = { 0 };
+	uint32_t id	  = 0;
+	int ret		  = 0;
+
+	ubus = ubus_connect(NULL);
+
+	if (!ubus) {
+		syslog(LOG_ERR, "Failed to connect to ubus");
+		goto end;
+	}
+
+	if (!port){
+		goto end;
+	}
+
+	if (strstr(host,".")){ //if host is IPv4 mapped IPv6 address
+		fix_mapped_ip(host);
+	} else {
+		strncpy(ip_address,host,sizeof(ip_address));
+	}
+
+	ret = ubus_lookup_id(ubus, "ip_block", &id);
+	if (ret) {
+		syslog(LOG_ERR, "Failed to find 'ip_block' object");
+		goto end;
+	}
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ip", ip_address);
+	blobmsg_add_string(&b, "port", port);
+	ubus_invoke(ubus, id, "push", b.head, NULL, NULL, 1000);
+
+end:
+	blob_buf_free(&b);
+	ubus_free(ubus);
+}
+
+static void push_log(char *format, ...)
+{
+
+	struct ubus_context *ubus = NULL;
+	ubus = ubus_connect(NULL);
+
+	if (!ubus) {
+		syslog(LOG_ERR, "Failed to connect to ubus");
+		return;
+	}
+
+	char el_text[200 + 1] = { 0 };
+	struct events_log el		      = {
+		 .table	   = LLOG_CONNECTIONS,
+		 .sender   = "Login",
+		 .text	   = el_text,
+		 .priority = EVENTLOG_NOTICE,
+		 .db_flag  = 1,
+	};
+
+	va_list ap;
+	va_start(ap, format);
+	vsnprintf(el.text, 200, format, ap);
+	va_end(ap);
+	llog_add_task(ubus, &el);
+
+	ubus_free(ubus);
+
+}
Index: busybox-1.34.1/networking/telnetd.c
===================================================================
--- busybox-1.34.1.orig/networking/telnetd.c
+++ busybox-1.34.1/networking/telnetd.c
@@ -155,6 +155,9 @@
 	struct tsession *sessions;
 	const char *loginpath;
 	const char *issuefile;
+#if ENABLE_FEATURE_TELNETD_STANDALONE
+	const char *port;
+#endif
 	int maxfd;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
@@ -426,7 +429,7 @@
 #if !ENABLE_FEATURE_TELNETD_STANDALONE
 	enum { sock = 0 };
 #endif
-	const char *login_argv[2];
+	const char *login_argv[6];
 	struct termios termbuf;
 	int fd, pid;
 	char tty_name[GETPTY_BUFSIZE];
@@ -435,6 +438,10 @@
 	/*ts->buf1 = (char *)(ts + 1);*/
 	/*ts->buf2 = ts->buf1 + BUFSIZE;*/

+	/* used to retreive IP addr info for passing into the login applet */
+	len_and_sockaddr *lsa = NULL;
+	char *ipaddr = NULL;
+
 	/* Got a new connection, set up a tty */
 	fd = xgetpty(tty_name);
 	if (fd > G.maxfd)
@@ -513,8 +520,16 @@

 	pid = getpid();

+	/* Acquire simple hostname */
+	lsa = get_peer_lsa(sock);
+	if (lsa) {
+		ipaddr = xmalloc_sockaddr2host_noport(&lsa->u.sa);
+		free(lsa);
+	}
+
+
 	if (ENABLE_FEATURE_UTMP) {
-		len_and_sockaddr *lsa = get_peer_lsa(sock);
+		lsa = get_peer_lsa(sock);
 		char *hostname = NULL;
 		if (lsa) {
 			hostname = xmalloc_sockaddr2dotted(&lsa->u.sa);
@@ -556,7 +571,16 @@

 	/* Exec shell / login / whatever */
 	login_argv[0] = G.loginpath;
-	login_argv[1] = NULL;
+	login_argv[1] = "-h";
+	login_argv[2] = strdup(ipaddr);
+	login_argv[3] = NULL;
+#if ENABLE_FEATURE_TELNETD_STANDALONE
+	if (G.port) {
+		login_argv[3] = "-P";
+		login_argv[4] = G.port;
+	}
+#endif
+	login_argv[5] = NULL;
 	/* exec busybox applet (if PREFER_APPLETS=y), if that fails,
 	 * exec external program.
 	 * NB: sock is either 0 or has CLOEXEC set on it.
@@ -701,6 +725,7 @@
 		logmode = LOGMODE_SYSLOG;
 	}
 #if ENABLE_FEATURE_TELNETD_STANDALONE
+	G.port = strdup(opt_portnbr);
 	if (IS_INETD) {
 		G.sessions = make_new_session(0);
 		if (!G.sessions) /* pty opening or vfork problem, exit */
