#!/bin/sh /etc/rc.common

START=07
STOP=90

USE_PROCD=1
STATE_F_PATH="/tmp/state/network_md5state"
LAN_TARGET=""

get_dhcp_sections() {

	local dhcp_state=""
	local new_l=$'\n'

	[ ! -f "/etc/config/dhcp" ] && echo "" && return 0

	config_cb() {

		[ "$1" != "dhcp" ] && return 1

		dhcp_state="${dhcp_state:-}$1.$2 ${new_l}"

		option_cb() {

			[ "$1" = "interface" ] && LAN_TARGET="${LAN_TARGET:-}$2 "

			dhcp_state="${dhcp_state}$1=$2 ${new_l}"
		}
	}

	config_load dhcp
	reset_cb

	echo "${dhcp_state%?}"

	return 0
}

get_lan_sections() {

	local lan_state=""
	local lan_sect=""
	local new_l=$'\n'

	[ ! -f "/etc/config/network" ] && echo "" && return 0

	lan_cb() {

		[[ "$LAN_TARGET" =~ "$1\b" ]] || return 1

		config_get proto "$1" "proto"
		[ "$proto" != "static" ] && return 1

		lan_state="${lan_state:-}interface.$1 ${new_l}"

		lan_state="${lan_state:-}ipaddr=$(config_get $1 "ipaddr") ${new_l}"
		lan_state="${lan_state:-}netmask=$(config_get "$1" "netmask") ${new_l}"
	}

	switch_vlan_cb() {
		lan_state="${lan_state:-}switch_vlan ${new_l}"

		lan_state="${lan_state:-}vlan=$(config_get "$1" "vlan") ${new_l}"
		lan_state="${lan_state:-}ports=$(config_get "$1" "ports") ${new_l}"
		lan_state="${lan_state:-}vid=$(config_get "$1" "vid") ${new_l}"
	}

	switch_cb() {
		lan_state="${lan_state:-}switch ${new_l}"
		lan_state="${lan_state:-}fiber_priority=$(config_get "$1" "fiber_priority") ${new_l}"
		lan_state="${lan_state:-}mirror_monitor_port=$(config_get "$1" "mirror_monitor_port") ${new_l}"
		lan_state="${lan_state:-}mirror_source_port=$(config_get "$1" "mirror_source_port") ${new_l}"
		lan_state="${lan_state:-}enable_mirror_rx=$(config_get "$1" "enable_mirror_rx") ${new_l}"
		lan_state="${lan_state:-}enable_mirror_tx=$(config_get "$1" "enable_mirror_tx") ${new_l}"
	}

	config_load network
	config_foreach lan_cb interface
	config_foreach switch_vlan_cb switch_vlan
	config_foreach switch_cb switch

	echo "${lan_state%?}"

	return 0
}

get_md5_state() {

	local data_set=$(get_dhcp_sections ; get_lan_sections)
	local md5_state=$(echo "$data_set" | md5sum | cut -d " " -f1)

	echo "$md5_state"

	return 0
}

save_lan_network_dhcp_state() {

	echo "lan: $(get_md5_state)" > "$STATE_F_PATH"

	return 0
}

compare_lan_dhcp_states() {

	[ ! -f "$STATE_F_PATH" ] && save_lan_network_dhcp_state && return 0

	local old_lan_md5=$(grep lan: "$STATE_F_PATH" | awk '{print $2}')
	local new_lan_md5=$(get_md5_state)

	[ "$old_lan_md5" != "$new_lan_md5" ] &&
		$(sed -i 's/^lan: .*$/lan: '$new_lan_md5'/' "$STATE_F_PATH") && return 0

	return 1
}

init_switch() {
	setup_switch() { return 0; }

	include /lib/network
	setup_switch
}

start_service() {
	init_switch

	procd_open_instance
	procd_set_param command /sbin/netifd
	procd_set_param respawn
	procd_set_param watch network.interface
	[ -e /proc/sys/kernel/core_pattern ] && {
		procd_set_param limits core="unlimited"
	}
	procd_close_instance

	save_lan_network_dhcp_state
}

reload_service() {
	local rv=0

	compare_lan_dhcp_states && init_switch

	[ -x /sbin/wifi ] && /sbin/wifi reload_legacy
	ubus call network reload || rv=1
	[ -x /sbin/wifi ] && /sbin/wifi kick_clients
	return $rv
}

stop_service() {
	[ -x /sbin/wifi ] && /sbin/wifi down
	ifdown -a
	sleep 5
}

restart() {
	stop
	start
	# need to sleep before init mobile (start not up all interfaces)
	sleep 5
	ubus -t 180 call mobifd reload
}

validate_atm_bridge_section()
{
	uci_validate_section network "atm-bridge" "${1}" \
		'unit:uinteger:0' \
		'vci:range(32, 65535):35' \
		'vpi:range(0, 255):8' \
		'atmdev:uinteger:0' \
		'encaps:or("llc", "vc"):llc' \
		'payload:or("bridged", "routed"):bridged'
}

validate_route_section()
{
	uci_validate_section network route "${1}" \
		'interface:string' \
		'target:cidr4' \
		'netmask:netmask4' \
		'gateway:ip4addr' \
		'metric:uinteger' \
		'mtu:uinteger' \
		'table:or(range(0,65535),string)'
}

validate_route6_section()
{
	uci_validate_section network route6 "${1}" \
		'interface:string' \
		'target:cidr6' \
		'gateway:ip6addr' \
		'metric:uinteger' \
		'mtu:uinteger' \
		'table:or(range(0,65535),string)'
}

validate_rule_section()
{
	uci_validate_section network rule "${1}" \
		'in:string' \
		'out:string' \
		'src:cidr4' \
		'dest:cidr4' \
		'tos:range(0,31)' \
		'mark:string' \
		'invert:bool' \
		'lookup:or(range(0,65535),string)' \
		'goto:range(0,65535)' \
		'action:or("prohibit", "unreachable", "blackhole", "throw")'
}

validate_rule6_section()
{
	uci_validate_section network rule6 "${1}" \
		'in:string' \
		'out:string' \
		'src:cidr6' \
		'dest:cidr6' \
		'tos:range(0,31)' \
		'mark:string' \
		'invert:bool' \
		'lookup:or(range(0,65535),string)' \
		'goto:range(0,65535)' \
		'action:or("prohibit", "unreachable", "blackhole", "throw")'
}

validate_switch_section()
{
	uci_validate_section network switch "${1}" \
		'name:string' \
		'enable:bool' \
		'enable_vlan:bool' \
		'reset:bool' \
		'ar8xxx_mib_poll_interval:uinteger' \
		'ar8xxx_mib_type:range(0,1)'
}

validate_switch_vlan()
{
	uci_validate_section network switch_vlan "${1}" \
		'device:string' \
		'vlan:uinteger' \
		'ports:list(ports)'
}

service_triggers()
{
	procd_add_reload_trigger network wireless

	procd_open_validate
	validate_atm_bridge_section
	validate_route_section
	[ -e /proc/sys/net/ipv6 ] && validate_route6_section
	validate_rule_section
	[ -e /proc/sys/net/ipv6 ] && validate_rule6_section
	validate_switch_section
	validate_switch_vlan
	procd_close_validate
}

shutdown() {
	ifdown -a
	sleep 5
}
